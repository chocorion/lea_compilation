%package "ubordeaux.deptinfo.compilation.project.main";
%class "ParserExpr";
%import "ubordeaux.deptinfo.compilation.project.node.*";
%import "ubordeaux.deptinfo.compilation.project.type.*";
%import "ubordeaux.deptinfo.compilation.project.environment.*";
%import "java.util.ArrayList";
%import "java.util.Iterator";
%import "java.util.*";

%embed {:

	static class Events extends beaver.Parser.Events {
		public void syntaxError(Symbol token) {
			System.err.format("*** Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()),
				Terminals.NAMES[token.getId()]);
		}
	}

	public void semanticError(String msg, Symbol token) {
			System.err.format("*** " + msg + " ligne %d, colonne %d\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()));
		}

	private Environment typeEnvironment = new Environment("types");
	private Environment procedureEnvironment = new Environment("procedures");
	private StackEnvironment stackEnvironment = new StackEnvironment("local variables stack");
	private String type_declaration_name;

:};

%init {:
	report = new Events();
:};

// KEYWORDS
%terminals TOKEN_TYPE, TOKEN_STRING, TOKEN_INTEGER, TOKEN_BOOLEAN, TOKEN_ARRAY, TOKEN_OF, TOKEN_STRUCT;
%terminals TOKEN_VAR, TOKEN_PROCEDURE, TOKEN_FUNCTION, TOKEN_BEGIN, TOKEN_END, TOKEN_NEW, TOKEN_DISPOSE;
%terminals TOKEN_PRINTLN, TOKEN_READLN, TOKEN_RETURN, TOKEN_IF, TOKEN_THEN, TOKEN_ELSE, TOKEN_WHILE, TOKEN_DO;
%terminals TOKEN_SWITCH, TOKEN_CASE, TOKEN_DEFAULT;

// PONCTS
%terminals TOKEN_SEMIC, TOKEN_DOTDOT, TOKEN_COLON, TOKEN_COMMA;
%terminals TOKEN_LPAR, TOKEN_RPAR, TOKEN_LBRACKET, TOKEN_RBRACKET, TOKEN_LBRACE, TOKEN_RBRACE;

// OPERATORS
%terminals TOKEN_AFF, TOKEN_CIRC;
%terminals TOKEN_PLUS, TOKEN_MINUS, TOKEN_TIMES, TOKEN_DIV;
%terminals TOKEN_AND, TOKEN_OR, TOKEN_NOT;
%terminals TOKEN_LT, TOKEN_LE, TOKEN_GT, TOKEN_GE, TOKEN_EQ, TOKEN_NE;

// LITERALS
%terminals TOKEN_IDENTIFIER, TOKEN_LIT_INTEGER, TOKEN_LIT_STRING, TOKEN_TRUE, TOKEN_FALSE, TOKEN_NULL;

/***
* A completer
***/

//D'apres ce que j'ai lu, faut mettre tous les operateurs en left,
//Sauf les operateurs if/then/else.
//Il semble qu'il faille bidouiller les if/then/else, la grammaire n'est pas tout a fait correcte

%right TOKEN_IF, TOKEN_THEN, TOKEN_ELSE;
%right TOKEN_CIRC;
%right UNARY_MINUS;
%right TOKEN_NOT;

%left TOKEN_AND, TOKEN_OR, TOKEN_NOT;
%left TOKEN_LT, TOKEN_LE, TOKEN_GT, TOKEN_GE, TOKEN_EQ, TOKEN_NE;
%left TOKEN_TIMES, TOKEN_DIV;
%left TOKEN_PLUS, TOKEN_MINUS;

%typeof program="Node";
%typeof type_declaration_part="NodeList";
%typeof literal="NodeLiteral";
%typeof expression="NodeExp";
%typeof case_default="NodeCase";
%typeof case_statement = "NodeCaseList";
%typeof case_statement_list = "NodeCaseList";
%typeof variable_access = "NodeExp";
%typeof identifier_list = "NodeList";
%typeof expression_list = "NodeList";
%typeof type_declaration_list="NodeList";
%typeof if_statement="NodeIf";
%typeof dispose_statement="NodeDispose";
%typeof return_statement="NodeReturn";
%typeof statement="Node";
%typeof switch_statement="NodeSwitch";
%typeof structured_statement="Node";

%goal program;

/***
* Semantique A completer
*
* Quelques astuces:
*
* a) ne mettez jamais de lettres accentuees, Beaver ne fonctionnerait pas
*
* b) quand vous souhaitez mettre du code avant la fin de la regle,
*     X= A {: je voudrais mettre du code ici :} B {: pour l'exploiter ici :}
* utilisez une rege vide comme ceci:
*
*     X= A empty_X B {: pour l'exploiter ici  :} ;
*     empty_X= {: je voudrais mettre du code ici :};
*
* c) pour implementer une liste, faites comme ceci:
* xxx_list=
*	xxx_list.list xxx.elt {: list.add(elt); return list; :}
*	| xxx.elt {: MyList list = new MyList(); list.add(elt); return list; :}
*	;
*
*
***/


program=
	type_declaration_part.p1
	variable_declaration_part.p2
	procedure_definition_part.p3
	TOKEN_BEGIN
	statement_list.p4
	TOKEN_END {:
		NodeList p = new NodeList();
		p.add(p1);
		p.add(p2);
		p.add(p3);
		p.add(p4);

		return p;
	:}
	;

type_declaration_part=
	/* empty */
	| TOKEN_TYPE type_declaration_list.e {:
		return e;
	:}
	;

type_declaration_list=
	type_declaration_list.l type_declaration.e {:
		l.add(e);
		return l;
	:}
	| type_declaration.e {:
		NodeList l = new NodeList();
		l.add(e);
		return l;
	:}
	;

type_declaration=
	type_declaration_head TOKEN_AFF type TOKEN_SEMIC
	;

type_declaration_head=
	TOKEN_IDENTIFIER
	;

type=
	simple_type
	| named_type
	| index_type
	| array_type
	| pointer_type
	| structure_type
	;

simple_type=
	TOKEN_STRING
	| TOKEN_INTEGER
	| TOKEN_BOOLEAN
	;

named_type=
	TOKEN_IDENTIFIER
	;

index_type=
	enumerated_type
	| subrange_type
	;

enumerated_type=
	init_enumerated_type TOKEN_LPAR identifier_list TOKEN_RPAR
	;

init_enumerated_type=
	;

subrange_type=
	TOKEN_LIT_INTEGER TOKEN_DOTDOT TOKEN_LIT_INTEGER
	| TOKEN_IDENTIFIER TOKEN_DOTDOT TOKEN_IDENTIFIER
	;

array_type=
	TOKEN_ARRAY TOKEN_LBRACKET range_type TOKEN_RBRACKET TOKEN_OF type
	;

range_type=
	enumerated_type
	| subrange_type
	| named_type
	;

pointer_type=
	TOKEN_CIRC type
	;

structure_type=
	TOKEN_STRUCT TOKEN_LBRACE feature_list_type TOKEN_RBRACE
	;

feature_list_type=
	feature_list_type feature_type
	| feature_type
	;

feature_type=
	TOKEN_IDENTIFIER TOKEN_COLON type TOKEN_SEMIC
	;

variable_declaration_part=
	/* empty */
	| TOKEN_VAR variable_declaration_list
	;

variable_declaration_list=
	variable_declaration_list variable_declaration
	| variable_declaration
	;

variable_declaration=
	identifier_list TOKEN_COLON type TOKEN_SEMIC
	;

identifier_list=
	identifier_list TOKEN_COMMA TOKEN_IDENTIFIER
	| TOKEN_IDENTIFIER
	;

procedure_definition_part=
	| procedure_definition_list
	;

procedure_definition_list=
	procedure_definition_list procedure_definition
	| procedure_definition
	;

procedure_definition=
	procedure_definition_head block
	| procedure_declaration_head TOKEN_SEMIC
	;

procedure_definition_head=
	procedure_head
	;

procedure_declaration_head=
	procedure_head
	;

procedure_head=
	TOKEN_PROCEDURE TOKEN_IDENTIFIER TOKEN_LPAR argt_part TOKEN_RPAR
	| TOKEN_FUNCTION TOKEN_IDENTIFIER TOKEN_LPAR argt_part TOKEN_RPAR TOKEN_COLON type
	;

argt_part=
	/* empty */
	| argt_list
	;

argt_list=
	argt_list TOKEN_COMMA argt
	| argt
	;

argt=
	TOKEN_IDENTIFIER TOKEN_COLON type
	;

block=
	variable_declaration_part
	TOKEN_BEGIN
	statement_list
	TOKEN_END
	;

statement_list=
	statement_list statement
	| statement
	;

statement=
	simple_statement
	| structured_statement
	;

simple_statement=
	assignment_statement
	| procedure_statement
	| new_statement
	| dispose_statement
	| println_statement
	| readln_statement
	| return_statement
	;

assignment_statement=
	variable_access TOKEN_AFF expression TOKEN_SEMIC
	;

procedure_statement=
	procedure_expression TOKEN_SEMIC
	;

procedure_expression=
	TOKEN_IDENTIFIER TOKEN_LPAR expression_part TOKEN_RPAR
	;

expression_part=
	/* empty */
	| expression_list
	;

expression_list=
	expression_list.l TOKEN_COMMA expression.e {:
		l.add(e);
		return l;
	:}
	| expression.e {:
		NodeList l = new NodeList();
		l.add(e);

		return l;
	:}
	;

new_statement=
	TOKEN_NEW variable_access TOKEN_SEMIC
	;

dispose_statement=
	TOKEN_DISPOSE variable_access.e TOKEN_SEMIC {:
		return new NodeDispose(e);
	:}
	;

println_statement=
	TOKEN_PRINTLN expression TOKEN_SEMIC
	;

readln_statement=
	TOKEN_READLN expression TOKEN_SEMIC
	;

return_statement=
	TOKEN_RETURN expression.e TOKEN_SEMIC {:
		return new NodeReturn(e);
	:}
	;

structured_statement=
	block.e {:return e;:}
	| if_statement.e {:return e;:}
	| while_statement.e {:return e;:}
	| switch_statement.e {:return e;:}
	;

if_statement=
	TOKEN_IF expression.e TOKEN_THEN statement.s {:
		return new NodeIf(e, s);
	:}
	| TOKEN_IF expression.e TOKEN_THEN statement.s1 TOKEN_ELSE statement.s2 {:
		return new NodeIf(e, s1, s2);
	:}
	;

while_statement=
	TOKEN_WHILE expression.e TOKEN_DO statement.t {:
		return new NodeWhile(e, t);
	:}
	;

switch_statement=
	TOKEN_SWITCH expression.e TOKEN_BEGIN case_statement_list.l TOKEN_END {:
		return new NodeSwitch(e, l);
	:}
	;

case_statement_list=
	case_statement_list.l case_statement.e case_default.d {:
		// The NodeCase's statement has to terminate the switch for this
		// implementation to work
		for(int x = 0; x < e.size(); x++) {
			l.add(e.get(x));
		}
		l.add(d);
		return l;
	:}
	| case_statement.e {:
		return e;
	:}
	;

case_statement=
	TOKEN_CASE identifier_list.i TOKEN_COLON statement.s
	{:
		NodeCaseList l = new NodeCaseList();
		for(int x = 0; x < i.size(); x++) {
			NodeId n = (NodeId) i.get(x);
			l.add(new NodeCase(n.toString(),s));
		}
		return l;
	:}
	;

case_default=
	/* empty */
	| TOKEN_DEFAULT TOKEN_COLON statement.s {:
		return new NodeCase(s);
	:}
	;

variable_access=
	TOKEN_IDENTIFIER.e {:
		String typename = typeEnvironment.getVariableValue((String)e.value);
		switch(typename) {
			case "int":
				return new NodeId((String)e.value, new TypeInt());
			case "string":
				return new NodeId((String)e.value, new TypeString());
			case "boolean":
				return new NodeId((String)e.value, new TypeBoolean());
			default:
				return new NodeId((String)e.value, new TypeNamed(typename));
		}
	:}
	| variable_access.t TOKEN_LBRACKET expression.e TOKEN_RBRACKET
	{:
		return new NodeArrayAccess(t,e);
	:}
	| expression.e TOKEN_CIRC
	{:
		return new NodePtrAccess(e);
	:}
	;

expression=
	expression.e1 TOKEN_PLUS expression.e2 {: return new NodeOp("PLUS",e1,e2); :}
	| expression.e1 TOKEN_MINUS expression.e2 {: return new NodeOp("MINUS",e1,e2); :}
	| expression.e1 TOKEN_TIMES expression.e2 {: return new NodeOp("TIMES",e1,e2); :}
	| expression.e1 TOKEN_DIV expression.e2 {: return new NodeOp("DIV",e1,e2); :}
	| TOKEN_MINUS expression.e @UNARY_MINUS {:
		return new NodeOp("MINUS", e);
	:}
	| expression.e1 TOKEN_OR expression.e2 {: return new NodeRel("OR", e1, e2); :}
	| expression.e1 TOKEN_AND expression.e2 {: return new NodeRel("AND", e1, e2); :}
	| TOKEN_NOT expression.e {:
		return new NodeRel("EQ", e,new NodeLiteral(new TypeBoolean(), false));
	:}
	| expression.e1 TOKEN_LT expression.e2 {: return new NodeRel("LT", e1, e2); :}
	| expression.e1 TOKEN_LE expression.e2 {: return new NodeRel("LE", e1, e2); :}
	| expression.e1 TOKEN_GT expression.e2 {: return new NodeRel("GT",e1,e2); :}
	| expression.e1 TOKEN_GE expression.e2 {: return new NodeRel("GE",e1,e2); :}
	| expression.e1 TOKEN_EQ expression.e2 {:
		//Est-ce que le nom est le bon ?
		return new NodeRel("EQ", e1, e2);
	:}
	| expression.e1 TOKEN_NE expression.e2 {: return new NodeRel("NE",e1,e2); :}
	| TOKEN_LPAR expression.e TOKEN_RPAR {:
		return e;
	:}
	| procedure_expression.e {:
		//Pas sur...
		return e;
	:}
	| variable_access.e {: return e; :}
	| literal.e {: return e; :}
	;

literal=
	TOKEN_LIT_INTEGER.e {:
	//TODO: Verifier la valeur et generer une erreur si elle est trop grande
		return new NodeLiteral(new TypeInt((Integer)e.value), e.value);
	:}
	| TOKEN_LIT_STRING.e {: return new NodeLiteral(new TypeString(), (String)e.value); :}
	| TOKEN_TRUE  {: return new NodeLiteral(new TypeBoolean(), true); :}
	| TOKEN_FALSE {: return new NodeLiteral(new TypeBoolean(), false);:}
	| TOKEN_NULL  {: return new NodeLiteral(new TypePointer(), null); :}
	;
