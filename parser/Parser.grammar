%package "ubordeaux.deptinfo.compilation.project.main";
%class "ParserExpr";
%import "ubordeaux.deptinfo.compilation.project.node.*";
%import "ubordeaux.deptinfo.compilation.project.type.*";
%import "ubordeaux.deptinfo.compilation.project.environment.*";
%import "java.util.ArrayList";
%import "java.util.Iterator";
%import "java.util.*";

%embed {:

	static class Events extends beaver.Parser.Events {
		public void syntaxError(Symbol token) {
			System.err.format("*** Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()),
				Terminals.NAMES[token.getId()]);
		}
	}

	public void semanticError(String msg, Symbol token) {
			System.err.format("*** " + msg + " ligne %d, colonne %d\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()));
		}

	private Environment typeEnvironment = new Environment("types");
	private Environment procedureEnvironment = new Environment("procedures");
	private StackEnvironment stackEnvironment = new StackEnvironment("local variables stack");
	private String type_declaration_name;

:};

%init {:
	report = new Events();
:};

// KEYWORDS
%terminals TOKEN_TYPE, TOKEN_STRING, TOKEN_INTEGER, TOKEN_BOOLEAN, TOKEN_ARRAY, TOKEN_OF, TOKEN_STRUCT;
%terminals TOKEN_VAR, TOKEN_PROCEDURE, TOKEN_FUNCTION, TOKEN_BEGIN, TOKEN_END, TOKEN_NEW, TOKEN_DISPOSE;
%terminals TOKEN_PRINTLN, TOKEN_READLN, TOKEN_RETURN, TOKEN_IF, TOKEN_THEN, TOKEN_ELSE, TOKEN_WHILE, TOKEN_DO;
%terminals TOKEN_SWITCH, TOKEN_CASE, TOKEN_DEFAULT;

// PONCTS
%terminals TOKEN_SEMIC, TOKEN_DOTDOT, TOKEN_COLON, TOKEN_COMMA;
%terminals TOKEN_LPAR, TOKEN_RPAR, TOKEN_LBRACKET, TOKEN_RBRACKET, TOKEN_LBRACE, TOKEN_RBRACE;

// OPERATORS
%terminals TOKEN_AFF, TOKEN_CIRC;
%terminals TOKEN_PLUS, TOKEN_MINUS, TOKEN_TIMES, TOKEN_DIV;
%terminals TOKEN_AND, TOKEN_OR, TOKEN_NOT;
%terminals TOKEN_LT, TOKEN_LE, TOKEN_GT, TOKEN_GE, TOKEN_EQ, TOKEN_NE;

// LITERALS
%terminals TOKEN_IDENTIFIER, TOKEN_LIT_INTEGER, TOKEN_LIT_STRING, TOKEN_TRUE, TOKEN_FALSE, TOKEN_NULL;

/***
* A completer
***/

//D'apres ce que j'ai lu, faut mettre tous les operateurs en left,
//Sauf les operateurs if/then/else.
//Il semble qu'il faille bidouiller les if/then/else, la grammaire n'est pas tout a fait correcte

%right TOKEN_IF, TOKEN_THEN, TOKEN_ELSE;
%right TOKEN_CIRC;
%right UNARY_MINUS;
%right TOKEN_NOT;

%left TOKEN_AND, TOKEN_OR, TOKEN_NOT;
%left TOKEN_LT, TOKEN_LE, TOKEN_GT, TOKEN_GE, TOKEN_EQ, TOKEN_NE;
%left TOKEN_TIMES, TOKEN_DIV;
%left TOKEN_PLUS, TOKEN_MINUS;

%typeof program="Node";
%typeof type_declaration_part="NodeList";
%typeof literal="NodeLiteral";
%typeof expression="NodeExp";
%typeof case_default="NodeCase";
%typeof case_statement = "NodeCaseList";
%typeof case_statement_list = "NodeCaseList";
%typeof variable_access = "NodeExp";
%typeof expression_list = "NodeList";
%typeof type_declaration_list="NodeList";
%typeof if_statement="NodeIf";
%typeof dispose_statement="NodeDispose";
%typeof return_statement="NodeReturn";
%typeof statement="Node";
%typeof switch_statement="NodeSwitch";
%typeof structured_statement="Node";
%typeof println_statement="NodeExp";
%typeof readln_statement="NodeExp";
%typeof new_statement="NodeNew";
%typeof expression_part="NodeList";
%typeof simple_statement="Node"; //Maybe
%typeof assignment_statement="NodeAssign";
%typeof procedure_expression="NodeCallFct";
%typeof procedure_statement="NodeCallFct";
%typeof statement_list="NodeList";
%typeof argt="NodeIf";
%typeof argt_list="NodeList";
%typeof argt_part="NodeList";
%typeof procedure_head="NodeCallFct";
%typeof procedure_declaration_head="NodeCallFct";
%typeof procedure_definition_head="NodeCallFct";
%typeof identifier_list="NodeList";
%typeof variable_declaration_list="NodeList";
%typeof variable_declaration="NodeList";
%typeof variable_declaration_part="NodeList";
%typeof structure_type="TypeStruct";

%typeof type="Type";
%typeof simple_type="TypeAtomic";
%typeof named_type="TypeNamed";
%typeof feature_type="TypeFeature";
%typeof feature_list_type="TypeFeatureList";
%typeof pointer_type="TypePointer";

%goal program;

/***
* Semantique A completer
*
* Quelques astuces:
*
* a) ne mettez jamais de lettres accentuees, Beaver ne fonctionnerait pas
*
* b) quand vous souhaitez mettre du code avant la fin de la regle,
*     X= A {: je voudrais mettre du code ici :} B {: pour l'exploiter ici :}
* utilisez une rege vide comme ceci:
*
*     X= A empty_X B {: pour l'exploiter ici  :} ;
*     empty_X= {: je voudrais mettre du code ici :};
*
* c) pour implementer une liste, faites comme ceci:
* xxx_list=
*	xxx_list.list xxx.elt {: list.add(elt); return list; :}
*	| xxx.elt {: MyList list = new MyList(); list.add(elt); return list; :}
*	;
*
*
***/


program=
	type_declaration_part.p1
	variable_declaration_part.p2
	procedure_definition_part.p3
	TOKEN_BEGIN
	statement_list.p4
	TOKEN_END {:
		NodeList p = new NodeList();
		p.add(p1);
		p.add(p2);
		p.add(p3);
		p.add(p4);

		return p;
	:}
	;

type_declaration_part=
	/* empty */
	| TOKEN_TYPE type_declaration_list.e {:
		return e;
	:}
	;

type_declaration_list=
	type_declaration_list.l type_declaration.e {:
		l.add(e);
		return l;
	:}
	| type_declaration.e {:
		NodeList l = new NodeList();
		l.add(e);
		return l;
	:}
	;

type_declaration=
	type_declaration_head TOKEN_AFF type TOKEN_SEMIC
	;

type_declaration_head=
	TOKEN_IDENTIFIER
	;

type=
	simple_type.e {: return e; :}
	| named_type.e {: return e; :}
	| index_type.e {: return e; :}
	| array_type.e {: return e; :}
	| pointer_type.e {: return e; :}
	| structure_type.e {: return e; :}
	;

simple_type=
	TOKEN_STRING {:
		return new TypeString();
	:}
	| TOKEN_INTEGER {:
		return new TypeInt();
	:}
	| TOKEN_BOOLEAN {:
		return new TypeBoolean();
	:}
	;

named_type=
	TOKEN_IDENTIFIER.e {:
		return new TypeNamed(e.value);
	:}
	;

index_type=
	enumerated_type
	| subrange_type
	;

enumerated_type=
	init_enumerated_type TOKEN_LPAR identifier_list TOKEN_RPAR
	;

init_enumerated_type=
	;

subrange_type=
	TOKEN_LIT_INTEGER TOKEN_DOTDOT TOKEN_LIT_INTEGER
	| TOKEN_IDENTIFIER TOKEN_DOTDOT TOKEN_IDENTIFIER
	;

array_type=
	TOKEN_ARRAY TOKEN_LBRACKET range_type TOKEN_RBRACKET TOKEN_OF type
	;

range_type=
	enumerated_type
	| subrange_type
	| named_type
	;

pointer_type=
	TOKEN_CIRC type.t {:
		return new TypePointer(t);
	:}
	;

structure_type=
	TOKEN_STRUCT TOKEN_LBRACE feature_list_type.t TOKEN_RBRACE {:
		return new TypeStruct(t.getType());
	:}
	;

feature_list_type=
	feature_list_type.e feature_type.f {:
		//Penser a verifier les types plus tard
		return e;
	:}
	| feature_type.e {:
		return new TypeFeatureList(e.getType());
	:}
	;

feature_type=
	TOKEN_IDENTIFIER.n TOKEN_COLON type.t TOKEN_SEMIC {:
		return new TypeFeature((String)n.value, t);
	:}
	;

variable_declaration_part=
	/* empty */
	| TOKEN_VAR variable_declaration_list.e {:
		//Pas sur
		return e;
	:}
	;

variable_declaration_list=
	variable_declaration_list.l variable_declaration.e {:
		l.add(e);

		return l;
	:}
	| variable_declaration.e {:
		NodeList l = new NodeList();
		l.add(e);

		return l;
	:}
	;

variable_declaration=
	identifier_list.l TOKEN_COLON type.t TOKEN_SEMIC {:
		NodeList declaration_list = new NodeList();

		for(int x = 0; x < l.size(); x++) {
			NodeId nodeid = (NodeId) l.get(x);
			nodeid.setType(t);
			l.add(nodeid);
		}

		return declaration_list;
	:}
	;

identifier_list=
	identifier_list.l TOKEN_COMMA TOKEN_IDENTIFIER.e {:
		l.add(new NodeId((String)e.value, new TypeVoid());
		return l;
	:}
	| TOKEN_IDENTIFIER.e {:
		NodeList l = new NodeList();
		NodeId n = new NodeId((String) e.value, new TypeVoid());
		l.add(n);
		return l;
	:}
	;

procedure_definition_part=
	| procedure_definition_list
	;

procedure_definition_list=
	procedure_definition_list.l procedure_definition.f
	{:
		l.add(f);
		return l;
	:}
	| procedure_definition.f
	{:
		NodeList l = new NodeList();
		l.add(f);
		return l;
	:}
	;

procedure_definition=
	procedure_definition_head.f block.b
	{:
		NodeList l = new NodeList();
		l.add(f);
		l.add(b);
		return l;
	:}
	| procedure_declaration_head TOKEN_SEMIC
	{:
		NodeList l = new NodeList();
		l.add(f);
		l.add(new NodeList());
		return l;
	:}
	;

procedure_definition_head=
	procedure_head.e
	{:
		return e;
	:}
	;

procedure_declaration_head=
	procedure_head.e
	{:
		return e;
	:}
	;

procedure_head=
	TOKEN_PROCEDURE TOKEN_IDENTIFIER.id TOKEN_LPAR argt_part.args TOKEN_RPAR
	{:
		return new NodeCallFct((String) id.value,new TypeFunct((String) id.value, new TypeTuple(), new TypeVoid()));
	:}
	| TOKEN_FUNCTION TOKEN_IDENTIFIER.id TOKEN_LPAR argt_part.args TOKEN_RPAR TOKEN_COLON type.t
	{:
		TypeTuple types = new TypeTuple();
		for(int x = 0; x < args.size(); x++) {
			types.add(((NodeId) args.get(x)).getType());
		}

		return new NodeCallFct((String) id.value,new TypeFunct((String) id.value, types, t));
	:}
	;

argt_part=
	/* empty */
	| argt_list.e {:
		return e;
	:}
	;

argt_list=
	argt_list.l TOKEN_COMMA argt.e {:
		l.add(e);

		return l;
	:}
	| argt.e {:
		NodeList l = new NodeList();
		l.add(e);

		return l;
	:}
	;

argt=
	TOKEN_IDENTIFIER.name TOKEN_COLON type.t
	{:
		//Mettre a jour l'environment qui nous permet d'enregistrer les types
		return new NodeId((String) name.value, t);
	:}

	;

block=
	variable_declaration_part.e1
	TOKEN_BEGIN
		statement_list.e2
	TOKEN_END
	{:
		NodeList l = new NodeList();
		l.add(e1);
		l.add(e2);
	:}
	;

statement_list=
	statement_list.l statement.e {:
		l.add(e);

		return l;
	:}
	| statement.e {:
		NodeList l = new NodeList();
		l.add(e);

		return l;
	:}
	;

statement=
	simple_statement.e {:
		return e;
	:}
	| structured_statement.e {:
		return e;
	:}
	;

simple_statement=
	assignment_statement.e {:
		return e;
	:}
	| procedure_statement.e {:
		return e;
	:}
	| new_statement.e {:
		return e;
	:}
	| dispose_statement.e {:
		return e;
	:}
	| println_statement.e {:
		return e;
	:}
	| readln_statement.e {:
		return e;
	:}
	| return_statement.e {:
		return e;
	:}
	;

assignment_statement=
	variable_access.v TOKEN_AFF expression.e TOKEN_SEMIC {:
		//Affectation d'une valeur dans une variable, penser a faire la verification du type
		return new NodeAssign(v, e); //Je ne suis pas sure que ce soit ce type de node a utiliser
	:}
	;

procedure_statement=
	procedure_expression.e TOKEN_SEMIC{:	//Je ne sais pas trop a quoi cela correspond
		return e;
	:}
	;

procedure_expression=
	TOKEN_IDENTIFIER.name TOKEN_LPAR expression_part.e TOKEN_RPAR {:
		//Appel de fonction, je pense qu'il faut renvoyer un node CallFct.
		//public NodeCallFct(String name, TypeFunct type, NodeList args)
		String n = (String) name.value;
		TypeFunct type = null; //TODO
		//J'imagine qu'on recupere le type en utilisant l'environment.. qui n'est pas encore implemente

		return new NodeCallFct(n, type, e);
	:}
	;

expression_part=
	/* empty */
	| expression_list.e {:
		return e;
	:}
	;

expression_list=
	expression_list.l TOKEN_COMMA expression.e {:
		l.add(e);
		return l;
	:}
	| expression.e {:
		NodeList l = new NodeList();
		l.add(e);

		return l;
	:}
	;

new_statement=
	TOKEN_NEW variable_access.e TOKEN_SEMIC {:
		return new NodeNew(e);
	:}
	;

dispose_statement=
	TOKEN_DISPOSE variable_access.e TOKEN_SEMIC {:
		return new NodeDispose(e);
	:}
	;

println_statement=
	TOKEN_PRINTLN expression.e TOKEN_SEMIC {:
		//Je ne suis pas sure de tout de ce qu'il faut renvoyer...
		return new NodeExp(e);
	:}
	;

readln_statement=
	TOKEN_READLN expression.e TOKEN_SEMIC {:
		//Je ne suis pas sure non plus pour celui-ci
		return new NodeExp(e);
	:}
	;

return_statement=
	TOKEN_RETURN expression.e TOKEN_SEMIC {:
		return new NodeReturn(e);
	:}
	;

structured_statement=
	block.e {:return e;:}
	| if_statement.e {:return e;:}
	| while_statement.e {:return e;:}
	| switch_statement.e {:return e;:}
	;

if_statement=
	TOKEN_IF expression.e TOKEN_THEN statement.s {:
		return new NodeIf(e, s);
	:}
	| TOKEN_IF expression.e TOKEN_THEN statement.s1 TOKEN_ELSE statement.s2 {:
		return new NodeIf(e, s1, s2);
	:}
	;

while_statement=
	TOKEN_WHILE expression.e TOKEN_DO statement.t {:
		return new NodeWhile(e, t);
	:}
	;

switch_statement=
	TOKEN_SWITCH expression.e TOKEN_BEGIN case_statement_list.l TOKEN_END {:
		return new NodeSwitch(e, l);
	:}
	;

case_statement_list=
	case_statement_list.l case_statement.e case_default.d {:
		// The NodeCase's statement has to terminate the switch for this
		// implementation to work
		for(int x = 0; x < e.size(); x++) {
			l.add(e.get(x));
		}
		l.add(d);
		return l;
	:}
	| case_statement.e {:
		return e;
	:}
	;

case_statement=
	TOKEN_CASE identifier_list.i TOKEN_COLON statement.s
	{:
		NodeCaseList l = new NodeCaseList();
		for(int x = 0; x < i.size(); x++) {
			NodeId n = (NodeId) i.get(x);
			l.add(new NodeCase(n.toString(),s));
		}
		return l;
	:}
	;

case_default=
	/* empty */
	| TOKEN_DEFAULT TOKEN_COLON statement.s {:
		return new NodeCase(s);
	:}
	;

variable_access=
	TOKEN_IDENTIFIER.e {:
		String typename = typeEnvironment.getVariableValue((String)e.value);
		switch(typename) {
			case "int":
				return new NodeId((String)e.value, new TypeInt());
			case "string":
				return new NodeId((String)e.value, new TypeString());
			case "boolean":
				return new NodeId((String)e.value, new TypeBoolean());
			default:
				return new NodeId((String)e.value, new TypeNamed(typename));
		}
	:}
	| variable_access.t TOKEN_LBRACKET expression.e TOKEN_RBRACKET
	{:
		return new NodeArrayAccess(t,e);
	:}
	| expression.e TOKEN_CIRC
	{:
		return new NodePtrAccess(e);
	:}
	;

expression=
	expression.e1 TOKEN_PLUS expression.e2 {: return new NodeOp("PLUS",e1,e2); :}
	| expression.e1 TOKEN_MINUS expression.e2 {: return new NodeOp("MINUS",e1,e2); :}
	| expression.e1 TOKEN_TIMES expression.e2 {: return new NodeOp("TIMES",e1,e2); :}
	| expression.e1 TOKEN_DIV expression.e2 {: return new NodeOp("DIV",e1,e2); :}
	| TOKEN_MINUS expression.e @UNARY_MINUS {:
		return new NodeOp("MINUS", e);
	:}
	| expression.e1 TOKEN_OR expression.e2 {: return new NodeRel("OR", e1, e2); :}
	| expression.e1 TOKEN_AND expression.e2 {: return new NodeRel("AND", e1, e2); :}
	| TOKEN_NOT expression.e {:
		return new NodeRel("EQ", e,new NodeLiteral(new TypeBoolean(), false));
	:}
	| expression.e1 TOKEN_LT expression.e2 {: return new NodeRel("LT", e1, e2); :}
	| expression.e1 TOKEN_LE expression.e2 {: return new NodeRel("LE", e1, e2); :}
	| expression.e1 TOKEN_GT expression.e2 {: return new NodeRel("GT",e1,e2); :}
	| expression.e1 TOKEN_GE expression.e2 {: return new NodeRel("GE",e1,e2); :}
	| expression.e1 TOKEN_EQ expression.e2 {:
		//Est-ce que le nom est le bon ?
		return new NodeRel("EQ", e1, e2);
	:}
	| expression.e1 TOKEN_NE expression.e2 {: return new NodeRel("NE",e1,e2); :}
	| TOKEN_LPAR expression.e TOKEN_RPAR {:
		return e;
	:}
	| procedure_expression.e {:
		//Pas sur...
		return e;
	:}
	| variable_access.e {: return e; :}
	| literal.e {: return e; :}
	;

literal=
	TOKEN_LIT_INTEGER.e {:
	//TODO: Verifier la valeur et generer une erreur si elle est trop grande
		return new NodeLiteral(new TypeInt((Integer)e.value), e.value);
	:}
	| TOKEN_LIT_STRING.e {: return new NodeLiteral(new TypeString(), (String)e.value); :}
	| TOKEN_TRUE  {: return new NodeLiteral(new TypeBoolean(), true); :}
	| TOKEN_FALSE {: return new NodeLiteral(new TypeBoolean(), false);:}
	| TOKEN_NULL  {: return new NodeLiteral(new TypePointer(), null); :}
	;
